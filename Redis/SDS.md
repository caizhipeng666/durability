# SDS

index|question
---|---
1|[SDS的用途](#用途)
2|[SDS与C字符串有何异同](#C字符串比较)
3|[13字节的SDS进行扩容<br>13MB的SDS进行扩容](#空间分配策略)<br>所需的存储空间
4|[SDS何时释放free](#惰性空间释放)
5|[SDS是否二进制安全](#二进制安全)


### 用途
```
1. 用作Redis key-value中的key
2. 用作缓存值中的字符串缓存值
```

### C字符串比较
```
0. 均使用’\0’表示结尾
1. 使用len值 -> 存放length -> O(1)
   : C字符串只能通过遍历字符串数组获取O(n)
2. 使用free -> 存放当前字符串数组未使用空间
   : 防止缓冲区溢出
     C字符串不会动态分配空间 -> strcat()拼接字符串时, 一旦空间不够, 会改写相邻内存地址的内容
     Redis-> free判断空间是否足够-> 扩容
   : 空间预分配 -> 减少字符串修改时带来的内存重新分配次数
     当SDS修改而free不满足时才会对SDS进行修改,
     此时, free会根据len进行修改, 以解决连续执行字符串增长所需的内存重新分配次数
```

### 空间分配策略
```
1. SDS修改之后, len(SDS) < 1MB:
   : free也将分配和len一样的空间
   Ex: 修改后13B的SDS -> 13B(len) + 13B(free) + 1B('\0') = 27B
2. SDS修改之后, len(SDS) >= 1MB:
   : free将分配1MB空间
   Ex: 修改后13MB的SDS -> 13MB(len) + 1MB(free) + 1B('\0')
```

### 惰性空间释放
```
用于SDS缩短操作, 程序并不立即使用内存重新分配来回收缩短后多出来的字节, 而是用free做存储 -> 等待将来使用

当然，有预留api去释放空间
```

### 二进制安全
```
1. C字符串只根据‘\0’判断字符串是否结束, 否则最先被读取的空字符会被认为是字符串结尾
   : 无法保存图片、音频、视频、压缩文件这样的二进制数据
2. SDS根据len判断字符串是否结束, 但也会在末尾加上’\0’空字符串表示结束
   : i. 使用buf存储字符串, 但buf不是一个普通(字符串)数组, 而是一个字节数组, 存进来是什么, 取出时就是什么
     ii. 末尾加上’\0’空字符串表示结束 -> 可以兼容部分C字符串函数
```